---
title: R/qtl2 user guide
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R/qtl2 user guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8](inputenc)
---

```{r knitr_opts, include=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4)
options(width=140)
```


[R/qtl2](http://kbroman.org/qtl2) (aka qtl2) is a reimplementation of the QTL analysis software
[R/qtl](http://rqtl.org), to better handle high-dimensional data
and complex cross designs.

We expect that basic analyses with R/qtl2 will generally be performed
in "batch" (for example, on a cluster) rather than interactively. And
so the software is split into three parts:
[qtl2geno](https://github.com/rqtl/qtl2geno) for genotype probability
calculations, [qtl2scan](https://github.com/rqtl/qtl2scan) for QTL
scans, and [qtl2plot](https://github.com/rqtl/qtl2plot) for data
visualization.


## Installation

R/qtl2 is early in development and so is not yet available on
[CRAN](http://cran.r-project.org).

You can install R/qtl2 from [GitHub](https://github.com/rqtl).

You first need to install the
[devtools](https://github.com/hadley/devtools) package, plus a set of
package dependencies: [yaml](https://cran.r-project.org/package=yaml),
[jsonlite](https://cran.r-project.org/package=jsonlite),
[data.table](https://cran.r-project.org/package=data.table),
and [RcppEigen](https://github.com/RcppCore/RcppEigen).
(Additional, secondary dependencies will also be installed)

```{r install_devtools_and_dep, eval=FALSE}
install.packages(c("devtools", "yaml", "jsonlite", "data.table", "RcppEigen"))
```

Then, install R/qtl2 using `devtools::install_github()`.

```{r install_qtl2, eval=FALSE}
library(devtools)
install_github(c("rqtl/qtl2geno", "rqtl/qtl2scan", "rqtl/qtl2plot"))
```

## Data file format

The input data file formats for [R/qtl](http://rqtl.org) cannot
handle complex crosses, and so for R/qtl2, we have defined a new
format for the data files. We'll describe it here briefly; for
details, see the separate
[vignette on the input file format](http://kbroman.org/qtl2/assets/vignettes/input_files.html).

QTL mapping data consists of a set of tables of data: marker
genotypes, phenotypes, marker maps, etc. In the new format, these
different tables are in separate comma-delimited (CSV) files. In each
file, the first column is a set of IDs for the rows, and the first row
is a set of IDs for the columns. For example, the phenotype data file
will have individual IDs in the first column and phenotype names in
the first row.

A few important changes in the tabular data:

- We will use not just the genetic marker map, but also a physical map
  (if available).
- Previously, phenotypes and covariates were combined. In the new
  format, we separate numeric phenotypes from the often
  non-numeric covariates.
- We define a table of &ldquo;phenotype covariates.&rdquo; These are
  [metadata](http://en.wikipedia.org/wiki/Metadata) describing the
  phenotypes. For example, in the case of a phenotype measured over
  time, one column in the phenotype covariate data could be the
  time of measurement. For gene expression data, we would have columns
  representing chromosome and physical position of genes, as well as
  gene IDs.

In additional to the set of CSV files with the primary data, we need a
separate &ldquo;control&rdquo; file with various control parameters
(or metadata), including the names of all of the other data files and
the genotype codes used in the genotype data file. The control file is
in a specific format using either [YAML](http://www.yaml.org) or
[JSON](http://json.org); these are human-readable text files for
representing relatively complex data.

A big advantage of this control file scheme is that it greatly
simplifies the function for reading in the data. That function,
`read_cross2()`, has a _single_ argument: the name (with path) of the
control file. So you can read in data like this:

```{r read_cross2, eval=FALSE}
library(qtl2geno)
grav2 <- read_cross2("~/my_data/grav2.yaml")
```

The large number of files is a bit cumbersome, so we've made it
possible to use a
[zip file](http://en.wikipedia.org/wiki/Zip_(file_format)) containing
all of the data files, and to read that zip file directly. There's even a
function for creating the zip file:

```{r create_zip, eval=FALSE}
zip_datafiles("~/my_data/grav2.yaml")
```

This `zip_datafiles()` function will read the control file to identify
all of the relevant data files and then zip them up into a file with
the same name and location, but with the extension `.zip` rather than
`.yaml` or `.json`.

To read the data back in, we use the same `read_cross2()` function,
providing the name (and path) of the zip file rather than the control
file.

```{r read_zip, eval=FALSE}
grav2 <- read_cross2("~/my_data/grav2.zip")
```

This can even be done with remote files.

```{r read_remote_zip, eval=FALSE}
grav2 <- read_cross2("http://kbroman.org/qtl2/assets/sampledata/grav2/grav2.zip")
```

Of course, the other advantage of the zip file is that it is
_compressed_ and so smaller than the combined set of CSV files.

The control file may be confusing for some users. To assist in its
construction, there's a function `write_control_file()` that takes the
large set of control parameters as input and then writes the YAML
control file in the appropriate format.

## Sample data sets

The R/qtl2 web site includes
[sample data files](http://kbroman.org/qtl2/pages/sampledata.html) in
the new format. Zipped versions of these datasets are included with
the [qtl2geno](https://github.com/rqtl/qtl2geno) package and can be
loaded into R using the `read_cross2()` function.

In the [qtl2geno package source](https://github.com/rqtl/qtl2geno),
the sample zip files are located in
[`qtl2geno/inst/extdata`](https://github.com/rqtl/qtl2geno/tree/master/inst/extdata).
In the installed version of the package, they are in
`qtl2geno/extdata`, within whatever directory your R packages were
installed. The R function `system.file()` can be used to construct the
path to these files.

For example, one of the sample data sets concerns a gravitropism
phenotype in a set of Arabidopsis recombinant inbred lines (RIL), from
[Moore et al. (2013) Genetics 195:1077-1086](http://www.genetics.org/content/195/3/1077.abstract).
The data are in `qtl2geno/extdata/grav2.zip`, which can be loaded as
follows:

```{r load_grav2, message=FALSE}
library(qtl2geno)
grav2 <- read_cross2( system.file("extdata", "grav2.zip", package="qtl2geno") )
```

Additional sample data sets, including data on Diversity Outbred (DO)
mice, are available at <https://github.com/rqtl/qtl2data>.

## Calculating genotype probabilities

The first basic task in QTL analysis is to calculate conditional
genotype probabilities, given the observed marker data, at each
putative QTL position. This is accomplished with the `calc_genoprob()`
function in the [qtl2geno](https://github.com/rqtl/qtl2geno)
package. Unlike the corresponding function in
[R/qtl](http://rqtl.org), `calc.genoprob()`, the result is not inserted back into the
input cross object, but is returned as a list of three-dimensional
arrays (one per chromosome). Each 3d array of probabilities is
arranged as individuals &times; genotypes &times; positions.

We'll use the
[iron dataset](https://github.com/kbroman/qtl2/tree/gh-pages/assets/sampledata/iron)
from
[Grant et al. (2006) Hepatology 44:174-185](http://www.ncbi.nlm.nih.gov/pubmed/16799992)
(an intercross) as an example:

```{r calc_genoprob}
library(qtl2geno)
iron <- read_cross2( system.file("extdata", "iron.zip", package="qtl2geno") )
pr <- calc_genoprob(iron, step=1, err=0.002)
```

To speed up the calculations with large datasets on a multi-core
machine, you can use the argument `cores`. With `cores=0`, the number
of available cores will be detected via
`parallel::detectCores()`. Otherwise, specify the number of cores as a
positive integer.

```{r calc_genoprob_multicore, eval=FALSE}
pr <- calc_genoprob(iron, step=1, err=0.002, cores=4)
```


The genome scan functions (see below) use genotype probabilities as
well as a matrix of phenotypes.
If you wished to perform a genome scan via an additive allele model,
you would first convert the genotype probabilities to allele
probabilities, using the function `genoprob_to_alleleprob()`.

```{r allele_probs}
apr <- genoprob_to_alleleprob(pr)
```

## Calculating a kinship matrix

If you wish to perform a genome scan by a linear mixed model,
accounting for the relationships among individuals (in other words,
including a random polygenic effect), you'll need to calculate a
kinship matrix for the individuals. This is accomplished with the
`calc_kinship()` function in
[qtl2geno](https://github.com/rqtl/qtl2geno).
It takes the genotype probabilities as input.

```{r calc_kinship}
kinship <- calc_kinship(pr)
```

By default, the genotype probabilities are converted to allele
probabilities, and the kinship matrix is calculated as the proportion
of shared alleles. To use genotype probabilities instead, use
`use_allele_probs=FALSE`. Also, the default is to only use the
probabilities along the grid of pseudomarkers (defined by the `step`
argument to `calc_genoprob()`); to use the probabilities at _all_
positions, use `use_grid_only=FALSE`. Further, by default we omit the
X chromosome and only use the autosomes. To include the X chromosome,
use `omit_x=FALSE`.

If, for your linear mixed model genome scan, you wish to use the
"leave one chromosome out" (LOCO) method (scan each
chromosome using a kinship matrix that is calculated using data from
all other chromosomes), use `type="loco"` in the call to
`calc_kinship()`.

```{r calc_kinship_loco}
kinship_loco <- calc_kinship(pr, "loco")
```

On a multi-core machine, you can get some speed-up via the `cores`
argument, as with `calc_genoprob()`.

```{r calc_kinship_loco_multicore, eval=FALSE}
kinship_loco <- calc_kinship(pr, "loco", cores=4)
```


## Special covariates for the X chromosome

In a QTL scan of the X chromosome, special covariates (such as sex)
may need to be included under the null hypothesis of no QTL, to avoid
spurious evidence of linkage. (See
[Broman et al. (2006) Genetics 174:2151-2158](http://www.genetics.org/content/174/4/2151.long).)

The particular X chromosome covariates depends on the cross, and can
be obtained with the [qtl2geno](https://github.com/rqtl/qtl2geno)
function `get_x_covar()`.

```{r x_covar}
Xcovar <- get_x_covar(iron)
```

## Performing a genome scan

To perform a genome scan by Haley-Knott regression
([Haley and Knott 1992](http://www.ncbi.nlm.nih.gov/pubmed/16718932)),
use the function `scan1()` in
[qtl2scan](https://github.com/rqtl/qtl2scan). (The functions above
were all from [qtl2geno](https://github.com/rqtl/qtl2geno); from here
forward, the functions are all from
[qtl2scan](https://github.com/rqtl/qtl2scan).)

`scan1()` takes as input the genotype probabilities, a matrix of
phenotypes, and then optional additive and interactive covariates, and
the special X chromosome covariates. Another option is to provide a
vector of weights.

```{r scan1}
library(qtl2scan)
out <- scan1(pr, iron$pheno, Xcovar=Xcovar)
```

On a multi-core machine, you can get some speed-up via the `cores`
argument, as with `calc_genoprob()` and `calc_kinship()`.

```{r scan1_multicore, eval=FALSE}
out <- scan1(pr, iron$pheno, Xcovar=Xcovar, cores=4)
```

The output of `scan1()` is a matrix of LOD scores, positions &times;
phenotypes.

The function `plot_scan1()` in the
[qtl2plot](https://github.com/rqtl/qtl2plot) package can be used to
plot the LOD curves. You can just write `plot()`, as there's an S3
method `plot.scan1()` and the output of `scan1()` has class `"scan1"`.
Use the argument `lodcolumn` to indicate which column to plot. Unlike the
`plot.scanone()` function in [R/qtl](http://rqtl.org), the
`plot_scan1()` function will only plot one set of LOD curves at a
time.

```{r plot_lod}
library(qtl2plot)
par(mar=c(5.1, 4.1, 1.1, 1.1))
ymx <- maxlod(out) # overall maximum LOD score
plot(out, lodcolumn=1, col="slateblue", ylim=c(0, ymx*1.02))
plot(out, lodcolumn=2, col="violetred", add=TRUE)
legend("topleft", lwd=2, col=c("slateblue", "violetred"), colnames(out$lod), bg="gray90")
```


## Performing a genome scan with a linear mixed model

To perform a genome scan using a linear mixed model, accounting for
relationships among individuals using a random polygenic effect, you also use
the function `scan1`; you just need to provide the argument `kinship`,
a kinship matrix (or, for the LOCO method, a list of kinship
matrices).

```{r scan1_pg}
out_pg <- scan1(pr, iron$pheno, kinship, Xcovar=Xcovar)
```

Again, on a multi-core machine, you can get some speed-up using the
`cores` argument.

```{r scan1_pg_multicore, eval=FALSE}
out_pg <- scan1(pr, iron$pheno, kinship, Xcovar=Xcovar, cores=4)
```

For the LOCO (leave one chromosome out) method, provide the list of
kinship matrices as obtained from `calc_kinship()` with
`method="loco"`.

```{r scan1_pg_loco}
out_pg_loco <- scan1(pr, iron$pheno, kinship_loco, Xcovar=Xcovar)
```

To plot the results, we again use `plot_scan1()` from the
[qtl2plot](https://github.com/rqtl/qtl2plot) package, or just type `plot()`.

Here is a plot of the LOD scores, by Haley-Knott regression and the linear
mixed model using either the standard kinship matrix or the LOCO
method.

```{r plot_lod_scan1_vs_pg}
color <- c("slateblue", "violetred", "green3")
par(mar=c(5.1, 4.1, 1.1, 1.1))
ymx <- max(rbind(out$lod, out_pg$lod, out_pg_loco$lod))
for(i in 1:2) {
    plot(out, lodcolumn=i, col=color[1], main=colnames(out)[i],
              ylim=c(0, ymx*1.02))
    plot(out_pg, lodcolumn=i, col=color[2], add=TRUE)
    plot(out_pg_loco, lodcolumn=i, col=color[3], add=TRUE, lty=2)
    legend("topleft", lwd=2, col=color, c("H-K", "LMM", "LOCO"), bg="gray90", lty=c(1,1,2))
}
```

For the liver phenotype (top panel), the three methods give quite
different results. The linear mixed model with an overall kinship
matrix gives much lower LOD scores than the other two methods.  On
chromosomes with some evidence of a QTL, the LOCO method gives higher
LOD scores than Haley-Knott, except on chromosome 16 where it gives
lower LOD scores.

For the spleen phenotype (bottom panel), the linear mixed model with an
overall kinship matrix again gives much lower LOD scores than the
other two methods. However, in this case Haley-Knott regression and
the LOCO method give quite similar results.

## Estimated QTL effects

The `scan1()` function return only LOD scores. To
obtain estimated QTL effects, use the function `scan1coef()`.
This function takes a single phenotype and the
genotype probabilities for a single chromosome and returns a matrix
with the estimated coefficients at each putative QTL location along
the chromosome.

For example, to get the estimated effects on chromosome 2 for the
liver phenotype, we'd do the following:

```{r est_effects_liver_c2}
c2eff <- scan1coef(pr[,"2"], iron$pheno[,"liver"])
```

The result is a matrix, `r nrow(c2eff)` positions &times; `r ncol(c2eff)`
genotypes. An attribute, `"map"` contains the positions of the
calculations. To plot the effects, use the function `plot_coef()` from
the [qtl2plot](https://github.com/rqtl/qtl2plot). There is again an S3
method function `plot.scan1coef()`, so one can just type `plot()`.
Use the argument `columns` to indicate which coefficient columns to plot.

```{r plot_effects_liver_c2}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
col <- c("slateblue", "violetred", "green3")
plot(c2eff, columns=1:3, col=col)
co <- c2eff$coef
for(i in 1:ncol(co))
    axis(side=4, at=co[nrow(co),i], colnames(co)[i], tick=FALSE, col.axis=col[i])
```

The default is to provide phenotype averages for each genotype
group. If instead you want additive and dominance effects, you can
provide a square matrix of _contrasts_, as follows:

```{r est_effects_liver_c2_contr}
c2effB <- scan1coef(pr[,"2"], iron$pheno[,"liver"],
                    contrasts=cbind(mu=c(1,1,1), a=c(-0.5, 0, 0.5), d=c(-0.5, 1, -0.5)))

```

The result will then contain the estimates of `mu`, `a`, and `d`.
Here's a plot of the additive and dominance effects, which are in the
second and third columns.


```{r plot_effects_liver_c2_contr}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
co <- c2effB$coef[,2:3]
ymx <- max(abs(co))
plot(c2effB, columns=2:3, col=col)
for(i in 1:2)
    axis(side=4, at=co[nrow(co),i], colnames(co)[i], tick=FALSE, col.axis=col[i])
```

If you provide a kinship matrix to `scan1coef()`, it fits a linear
mixed model (LMM) to account for a residual polygenic effect. Here
let's use the kinship matrix from the LOCO method.

```{r est_effects_pg_liver_c2}
c2eff_pg <- scan1coef(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]])
```

Here's a plot of the estimates.

```{r plot_effects_pg_liver_c2}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
map <- attr(c2eff_pg, "map")[[1]]
col <- c("slateblue", "violetred", "green3")
plot(c2eff_pg, columns=1:3, col=col, ylab="Phenotype average")
co <- c2eff$coef
for(i in 1:ncol(co))
    axis(side=4, at=co[nrow(co), i], colnames(co)[i], tick=FALSE, col.axis=col[i])
```

You can also get estimated additive and dominance effects, using a
matrix of contrasts.

```{r est_effects_pg_liver_c2_contr}
c2effB_pg <- scan1coef(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]],
                       contrasts=cbind(mu=c(1,1,1), a=c(-0.5, 0, 0.5), d=c(-0.5, 1, -0.5)))
```

Here's a plot of the results.

```{r plot_effects_pg_liver_c2_contr}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
co <- c2effB_pg$coef[,2:3]
ymx <- max(abs(co))
plot(c2effB_pg, columns=2:3, col=col)
for(i in 1:2)
    axis(side=4, at=co[nrow(co),i], colnames(co)[i], tick=FALSE, col.axis=col[i])
```

Another option for estimating the QTL effects is to treat them as
random effects and calculate Best Linear Unbiased Predictors
(BLUPs). This is particularly valuable for multi-parent populations
such as the Collaborative Cross and Diversity Outbred mice, where the
large number of possible genotypes at a QTL lead to considerable
variability in the effect estimates. To calculate BLUPs, use
`scan1blup()`; it takes the same arguments as `scan1coef()`, including
the option of a kinship matrix to account for a residual polygenic
effect.

```{r scan1blup}
c2blup <- scan1blup(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]])
```

Here is a plot of the BLUPs (as dashed curves) alongside the standard
estimates. Note that

```{r plot_scan1blup}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
map <- attr(c2eff_pg, "map")[[1]]
col <- c("slateblue", "violetred", "green3")
ylim <- range(c(c2blup$coef, c2eff$coef))+c(-1,1)
plot(c2eff, columns=1:3, col=col, ylab="Phenotype average", ylim=ylim,
     xlab="Chr 2 position")
plot(c2blup, columns=1:3, col=col, add=TRUE, lty=2)
co <- c2eff$coef
for(i in 1:ncol(co))
    axis(side=4, at=co[nrow(co), i], colnames(co)[i], tick=FALSE, col.axis=col[i])
```


## SNP association

For multi-parent crosses, it can be useful to collapse the genotype or
allele probabilities according to the founder genotypes of the various
SNPs in the region of a QTL.

### QTL analysis in Diversity Outbred mice

To illustrate this sort of SNP association analysis, we'll consider some
Diversity Outbred mouse data. The Diversity Outcross (DO) mice are an
advanced intercross population derived from the same eight founder strains
as the Collaborative Cross (CC). See
[Svenson et al. (2012)](http://www.ncbi.nlm.nih.gov/pubmed/22345611)
and
[Gatti et al. (2014)](http://www.ncbi.nlm.nih.gov/pubmed/25237114).

We'll consider a subset of the data from
[Recla et al. (2014)](http://www.ncbi.nlm.nih.gov/pubmed/24700285),
available as part of the
[qtl2data github repository](https://github.com/rqtl/qtl2data). (The
full data are in
[`DO_Recla`](https://github.com/rqtl/qtl2data/tree/master/DO_Recla);
the directory
[`DOex`](https://github.com/rqtl/qtl2data/tree/master/DOex) contains a
reduced set, with just three chromosomes, one phenotype
(`OF_immobile_pct`, percent immobile in the open field test), and a
reduced set of markers.

You can download the data from a single zip file, as follows:

```{r read_DOex_data}
file <- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex.zip")
DOex <- read_cross2(file)
```

Let's quickly whip through a basic analysis.

We first calculate genotype probabilities and convert them to allele
probabilities.

```{r DOex_calc_genoprob, eval=FALSE}
pr <- calc_genoprob(DOex, error_prob=0.002)
apr <- genoprob_to_alleleprob(pr)
```

```{r download_alleleprobs, echo=FALSE, results="hide"}
tmpfile <- tempfile()
file <- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex_alleleprobs.rds")
download.file(file, tmpfile, quiet=TRUE)
apr <- readRDS(tmpfile)
unlink(tmpfile)
```

We calculate kinship matrices (using the "loco" method, though with the
caveat that here we are only considering genotypes on three chromosomes).

```{r DOex_calc_kinship}
k <- calc_kinship(apr, "loco")
```

We create a numeric covariate for sex; be sure to include the individual
IDs as names.

```{r DOex_create_sex_covar}
sex <- (DOex$covar$Sex == "male")*1
names(sex) <- rownames(DOex$covar)
```

We perform a genome scan with a linear mixed model (adjusting for
a residual polygenic effect), with sex as an additive covariate.

```{r DOex_scan1_pg}
out <- scan1(apr, DOex$pheno, k, sex)
```

Here's a plot of the results.

```{r plot_DOex_scan}
par(mar=c(5.1, 4.1, 0.6, 0.6))
plot(out)
```

There's a strong peak on chromosome 2. Let's look at the QTL effects.
We estimate them with `scan1coef()`. We need to subset the allele
probabilities and the list of kinship matrices.

```{r DOex_effects_c2}
coef_c2 <- scan1coef(apr[,"2"], DOex$pheno, k[["2"]], sex)
```

For the DO, with 8 QTL alleles, we can use the function `plot_coefCC`
in the [R/qtl2plot](https://github.com/rqtl/qtl2plot) package, which
plots the 8 allele effects in the "official" Collaborative Cross (CC)
colors. (Well, actually _slightly_ modified colors, because I think the
official colors are kind of ugly.) The strong locus seems to be mostly
due to the NZO allele. Note that `CCcolors` is a vector of colors
included in the qtl2plot package; there's also a `CCorigcolors` object
with the _official_ colors.

```{r plot_DOex_effects}
par(mar=c(5.1, 4.1, 0.6, 0.6))
plot_coefCC(coef_c2, bgcolor="gray95")
legend("bottomleft", col=CCcolors, names(CCcolors), ncol=2, lwd=2, bg="gray95")
```

### SNP associations

Okay, now finally we get to the SNP associations. We have a large peak
on chromosome 2, and we want to look at individual SNPs in the region
of the locus.

Well, actually, we first need to find the location of the inferred
QTL.  The peak LOD score on chromosome 2 occurs at
`r round(max(out, chr="2")$pos, 1)` cM. But to find nearby SNPs, we really want
to know the Mbp position. The calculations were only performed at the
marker positions, and so we need to find the peak marker and then
find it's physical location:

```{r DOex_find_peak_in_Mbp}
marker <- rownames(max(out, chr="2"))
peak_Mbp <- DOex$pmap[["2"]][marker]
```

The marker is at `r round(peak_Mbp, 1)` Mbp.

Now we need to identify the SNPs in this region. We'll focus on a 2
Mbp interval centered at `r round(peak_Mbp, 1)` Mbp. We're still
working on how best to quickly access SNP data. In the meantime, we
can grab a predefined table of SNPs that's available in the
[qtl2data repository](https://github.com/rqtl/qtl2data). It's saved as
an RDS file, which is a slight hassle to load over the web.

```{r load_c2_snps}
tmpfile <- tempfile()
file <- "https://raw.githubusercontent.com/rqtl/qtl2data/master/DOex/c2_snpinfo.rds"
download.file(file, tmpfile, quiet=TRUE)
snpinfo <- readRDS(tmpfile)
unlink(tmpfile)
```

Here's the first few rows of the data. The columns are the SNP name,
the chromosome, the Mbp position (in Mouse genome build 38), the
alleles (with the B6 allele before the `|` and any other alleles
after; in the case of multiple alternate alleles, they are separated
by `/`). Finally, there are eight columns of genotypes for the 8 CC
founder strains, coded as `1`/`3`.

```{r head_snpinfo}
head(snpinfo)
```

We first convert the founder genotypes to a "strain distribution
pattern" (SDP): an integer whose binary encoding corresponds to the 8
founders' genotypes.

```{r calc_sdp}
snpinfo$sdp <- calc_sdp(snpinfo[,-(1:4)])
```

We've added the SDP as an additional column.

```{r head_snpinfo_with_sdp}
head(snpinfo)
```

(Note that there's also a function `invert_sdp()` for converting the
SDPs back into founder genotypes.)

To perform the SNP association analysis, we first use the allele
probabilities and the founder SNP genotypes to infer the SNP genotypes
for the DO mice. That is, at each SNP, we want to collapse the eight
founder allele probabilities to two SNP allele probabilities, using
the the SNP genotypes of the founders.

We do this assuming that the allele probabilities were
calculated sufficiently densely that they can be assumed to be
constant in intervals. With this assumption, we then:

- Find the interval for each SNP.
- Reduce the SNPs to a "distinct" set: if two SNPs have the same SDP
  and are in the same interval, by our assumption their allele
  probabilities will be the same.
- Take the average of the allele probabilities at the two endpoints of
  each interval.
- Collapse the 8 allele probabilities to two according to each
  observed SDP in the interval.

We further create a look-up table relating the full set of SNPs to the
reduced set (one of each observed SDP in each interval).

The process is performed with the function `genoprob_to_snpprob()`,
which takes the allele probabilities (or the full genotype
probabilities, if you want to use a full 3-genotype model at each
SNP), plus the SNP information table (including the SDP column).

**But** there's one other problem: the map connected to our allele
probabilities is in cM, but our SNP information is in Mbp. But we can
plug in the physical map which is contained in the `DOex` object.

```{r switch_to_Mbp}
apr_Mbp <- apr
apr_Mbp$map <- DOex$pmap
```

We can do it like this because we'd calculated the allele
probabilities only at the observed markers. If we'd also calculated
probabilities at pseudomarker positions between markers, we'd need to
use interpolation to get the Mbp positions of the
pseudomarkers. There's a function `interp_map()` for assisting with
that.

So now we can calculate the SNP probabilities.

```{r calc_snpprobs}
snppr <- genoprob_to_snpprob(apr_Mbp, snpinfo)
```

We can then use the object to perform the SNP association analysis in
the region, using the same linear mixed model. We need to be sure to
use the correct kinship matrix.

```{r perform_snp_scan}
out_snps <- scan1(snppr, DOex$pheno, k[["2"]], sex)
```

The function `plot_snpasso()` in the qtl2plot package can be used to
plot the results, with points at each of the SNPs. The default is to
plot **all** SNPs: We calculated LOD scores only at a set of distinct
SNPs, but SNPs in the same interval with the same SDP will have the
same LOD score.

```{r plot_snp_asso}
par(mar=c(5.1, 4.1, 0.6, 0.6))
plot_snpasso(out_snps)
```

To get a table of the SNPs with the largest LOD scores, use the
function `top_snps()`. This will show all SNPs with LOD score within
some amount (the default is 1.5) of the maximum SNP LOD score.

```{r top_snps}
top_snps(out_snps)
```

The top SNPs all have NZO and CAST with a common allele, different
from the other 6 founders. The next-best SNPs have NZO with a unique
allele. Note that there's one SNP with two alternate alleles
(`C|G/T`). We are requiring that SNPs have just two alleles, and so we
group the alternate alleles together, though there's not a good reason
for this.

We can highlight these top SNPs in the SNP association plot using the
`drop` argument.

```{r plot_snp_asso_hilit}
par(mar=c(5.1, 4.1, 0.6, 0.6))
plot_snpasso(out_snps, drop=1.5)
```
