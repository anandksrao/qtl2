---
title: R/qtl2 user guide
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R/qtl2 user guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8](inputenc)
---

```{r knitr_opts, include=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4)
```


[R/qtl2](http://kbroman.org/qtl2) (aka qtl2) is a reimplementation of the QTL analysis software
[R/qtl](http://rqtl.org), to better handle high-dimensional data
and complex cross designs.

We expect that basic analyses with R/qtl2 will generally be performed
in "batch" (for example, on a cluster) rather than interactively. And
so the software is split into three parts:
[qtl2geno](https://github.com/rqtl/qtl2geno) for genotype probability
calculations, [qtl2scan](https://github.com/rqtl/qtl2scan) for QTL
scans, and [qtl2plot](https://github.com/rqtl/qtl2plot) for data
visualization.


## Installation

R/qtl2 is early in development and so is not yet available on
[CRAN](http://cran.r-project.org).

You can install R/qtl2 from [GitHub](http://github.com/rqtl).

You first need to install the
[devtools](https://github.com/hadley/devtools) package, plus a set of
package dependencies: [yaml](https://cran.r-project.org/package=yaml),
[jsonlite](https://cran.r-project.org/package=jsonlite),
[data.table](https://cran.r-project.org/package=data.table),
and [RcppEigen](https://github.com/RcppCore/RcppEigen).
(Additional, secondary dependencies will also be installed)

```{r install_devtools_and_dep, eval=FALSE}
install.packages(c("devtools", "yaml", "jsonlite", "data.table", "RcppEigen"))
```

Then, install R/qtl2 using `devtools::install_github()`.

```{r install_qtl2, eval=FALSE}
library(devtools)
install_github(c("rqtl/qtl2geno", "rqtl/qtl2scan", "rqtl/qtl2plot"))
```

## Data file format

The input data file formats for [R/qtl](http://rqtl.org) cannot
handle complex crosses, and so for R/qtl2, we have defined a new
format for the data files. We'll describe it here briefly; for
details, see the separate
[vignette on the input file format](http://kbroman.org/qtl2/assets/vignettes/input_files.html).

QTL mapping data consists of a set of tables of data: marker
genotypes, phenotypes, marker maps, etc. In the new format, these
different tables are in separate comma-delimited (CSV) files. In each
file, the first column is a set of IDs for the rows, and the first row
is a set of IDs for the columns. For example, the phenotype data file
will have individual IDs in the first column and phenotype names in
the first row.

A few important changes in the tabular data:

- We will use not just the genetic marker map, but also a physical map
  (if available).
- Previously, phenotypes and covariates were combined. In the new
  format, we separate numeric phenotypes from the often
  non-numeric covariates.
- We define a table of &ldquo;phenotype covariates.&rdquo; These are
  [metadata](http://en.wikipedia.org/wiki/Metadata) describing the
  phenotypes. For example, in the case of a phenotype measured over
  time, one column in the phenotype covariate data could be the
  time of measurement. For gene expression data, we would have columns
  representing chromosome and physical position of genes, as well as
  gene IDs.

In additional to the set of CSV files with the primary data, we need a
separate &ldquo;control&rdquo; file with various control parameters
(or metadata), including the names of all of the other data files and
the genotype codes used in the genotype data file. The control file is
in a specific format using either [YAML](http://www.yaml.org) or
[JSON](http://json.org); these are human-readable text files for
representing relatively complex data.

A big advantage of this control file scheme is that it greatly
simplifies the function for reading in the data. That function,
`read_cross2()`, has a _single_ argument: the name (with path) of the
control file. So you can read in data like this:

```{r read_cross2, eval=FALSE}
library(qtl2geno)
grav2 <- read_cross2("~/my_data/grav2.yaml")
```

The large number of files is a bit cumbersome, so we've made it
possible to use a
[zip file](http://en.wikipedia.org/wiki/Zip_(file_format)) containing
all of the data files, and to read that zip file directly. There's even a
function for creating the zip file:

```{r create_zip, eval=FALSE}
zip_datafiles("~/my_data/grav2.yaml")
```

This `zip_datafiles()` function will read the control file to identify
all of the relevant data files and then zip them up into a file with
the same name and location, but with the extension `.zip` rather than
`.yaml` or `.json`.

To read the data back in, we use the same `read_cross2()` function,
providing the name (and path) of the zip file rather than the control
file.

```{r read_zip, eval=FALSE}
grav2 <- read_cross2("~/my_data/grav2.zip")
```

This can even be done with remote files.

```{r read_remote_zip, eval=FALSE}
grav2 <- read_cross2("http://kbroman.org/qtl2/assets/sampledata/grav2/grav2.zip")
```

Of course, the other advantage of the zip file is that it is
_compressed_ and so smaller than the combined set of CSV files.

The control file may be confusing for some users. To assist in its
construction, there's a function `write_control_file()` that takes the
large set of control parameters as input and then writes the YAML
control file in the appropriate format.

## Sample data sets

The R/qtl2 web site includes
[sample data files](http://kbroman.org/qtl2/pages/sampledata.html) in
the new format. Zipped versions of these datasets are included with
the [qtl2geno](https://github.com/rqtl/qtl2geno) package and can be
loaded into R using the `read_cross2()` function.

In the [qtl2geno package source](https://github.com/rqtl/qtl2geno),
the sample zip files are located in
[`qtl2geno/inst/extdata`](https://github.com/rqtl/qtl2geno/tree/master/inst/extdata).
In the installed version of the package, they are in
`qtl2geno/extdata`, within whatever directory your R packages were
installed. The R function `system.file()` can be used to construct the
path to these files.

For example, one of the sample data sets concerns a gravitropism
phenotype in a set of Arabidopsis recombinant inbred lines (RIL), from
[Moore et al. (2013) Genetics 195:1077-1086](http://www.genetics.org/content/195/3/1077.abstract).
The data are in `qtl2geno/extdata/grav2.zip`, which can be loaded as
follows:

```{r load_grav2, message=FALSE}
library(qtl2geno)
grav2 <- read_cross2( system.file("extdata", "grav2.zip", package="qtl2geno") )
```

Additional sample data sets, including data on Diversity Outbred (DO)
mice, are available at <https://github.com/rqtl/qtl2data>.

## Calculating genotype probabilities

The first basic task in QTL analysis is to calculate conditional
genotype probabilities, given the observed marker data, at each
putative QTL position. This is accomplished with the `calc_genoprob()`
function in the [qtl2geno](https://github.com/rqtl/qtl2geno)
package. Unlike the corresponding function in
[R/qtl](http://rqtl.org), `calc.genoprob()`, the result is not inserted back into the
input cross object, but is returned as a list of three-dimensional
arrays (one per chromosome). Each 3d array of probabilities is
arranged as individuals &times; gneotypes &times; positions.

We'll use the
[iron dataset](https://github.com/kbroman/qtl2/tree/gh-pages/assets/sampledata/iron)
from
[Grant et al. (2006) Hepatology 44:174-185](http://www.ncbi.nlm.nih.gov/pubmed/16799992)
(an intercross) as an example:

```{r calc_genoprob}
library(qtl2geno)
iron <- read_cross2( system.file("extdata", "iron.zip", package="qtl2geno") )
pr <- calc_genoprob(iron, step=1, err=0.002)
```

To speed up the calculations with large datasets on a multi-core
machine, you can use the argument `cores`. With `cores=0`, the number
of available cores will be detected via
`parallel::detectCores()`. Otherwise, specify the number of cores as a
positive integer.

```{r calc_genoprob_multicore, eval=FALSE}
pr <- calc_genoprob(iron, step=1, err=0.002, cores=4)
```


The genome scan functions (see below) use genotype probablities as
well as a matrix of phenotypes.
If you wished to perform a genome scan via an additive allele model,
you would first convert the genotype probabilities to allele
probabilities, using the function `genoprob_to_alleleprob()`.

```{r allele_probs}
apr <- genoprob_to_alleleprob(pr)
```

## Calculating a kinship matrix

If you wish to perform a genome scan by a linear mixed model,
accounting for the relationships among individuals (in other words,
including a random polygenic effect), you'll need to calculate a
kinship matrix for the individuals. This is accomplished with the
`calc_kinship()` function in
[qtl2geno](https://github.com/rqtl/qtl2geno).
It takes the genotype probabilities as input.

```{r calc_kinship}
kinship <- calc_kinship(pr)
```

By default, the genotype probabilities are converted to allele
probabilities, and the kinship matrix is calculated as the proportion
of shared alleles. To use genotype probabilities instead, use
`use_allele_probs=FALSE`. Also, the default is to only use the
probabilities along the grid of pseudomarkers (defined by the `step`
argument to `calc_genoprob()`); to use the probabilities at _all_
positions, use `use_grid_only=FALSE`. Further, by default we omit the
X chromosome and only use the autosomes. To include the X chromosome,
use `omit_x=FALSE`.

If, for your linear mixed model genome scan, you wish to use the
"leave one chromosome out" (LOCO) method (scan each
chromosome using a kinship matrix that is calculated using data from
all other chromosomes), use `type="loco"` in the call to
`calc_kinship()`.

```{r calc_kinship_loco}
kinship_loco <- calc_kinship(pr, "loco")
```

On a multi-core machine, you can get some speed-up via the `cores`
argument, as with `calc_genoprob()`.

```{r calc_kinship_loco_multicore, eval=FALSE}
kinship_loco <- calc_kinship(pr, "loco", cores=4)
```


## Special covariates for the X chromosome

In a QTL scan of the X chromosome, special covariates (such as sex)
may need to be included under the null hypothesis of no QTL, to avoid
spurious evidence of linkage. (See
[Broman et al. (2006) Genetics 174:2151-2158](http://www.genetics.org/content/174/4/2151.long).)

The particular X chromosome covariates depends on the cross, and can
be obtained with the [qtl2geno](https://github.com/rqtl/qtl2geno)
function `get_x_covar()`.

```{r x_covar}
Xcovar <- get_x_covar(iron)
```

## Performing a genome scan

To perform a genome scan by Haley-Knott regression
([Haley and Knott 1992](http://www.ncbi.nlm.nih.gov/pubmed/16718932)),
use the function `scan1()` in
[qtl2scan](https://github.com/rqtl/qtl2scan). (The functions above
were all from [qtl2geno](https://github.com/rqtl/qtl2geno); from here
forward, the functions are all from
[qtl2scan](https://github.com/rqtl/qtl2scan).)

`scan1()` takes as input the genotype probabilities, a matrix of
phenotypes, and then optional additive and interactive covariates, and
the special X chromosome covariates. Another option is to provide a
vector of weights.

```{r scan1}
library(qtl2scan)
out <- scan1(pr, iron$pheno, Xcovar=Xcovar)
```

On a multi-core machine, you can get some speed-up via the `cores`
argument, as with `calc_genoprob()` and `calc_kinship()`.

```{r scan1_multicore, eval=FALSE}
out <- scan1(pr, iron$pheno, Xcovar=Xcovar, cores=4)
```

The output of `scan1()` is a matrix of LOD scores, positions &times;
phenotypes.

The function `plotscan1()` in the
[qtl2plot](https://github.com/rqtl/qtl2plot) package can be used to
plot the LOD curves.

```{r plot_lod}
library(qtl2plot)
par(mar=c(5.1, 4.1, 1.1, 1.1))
ymx <- max(out)
plotscan1(out, lod=1, col="slateblue", ylim=c(0, ymx*1.02))
plotscan1(out, lod=2, col="violetred", add=TRUE)
legend("topleft", lwd=2, col=c("slateblue", "violetred"), colnames(out), bg="gray92")
```


## Performing a genome scan with a linear mixed model

To perform a genome scan using a linear mixed model, accounting for
relationships among individuals using a random polygenic effect, use
the function `scan1_lmm()`. It takes the same input as `scan1()` plus
a kinship matrix (or, for the LOCO method, a list of kinship
matrices).

```{r scan1_lmm}
out_lmm <- scan1_lmm(pr, iron$pheno, kinship, Xcovar=Xcovar)
```

Again, on a multi-core machine, you can get some speed-up using the
`cores` argument.

```{r scan1_lmm_multicore, eval=FALSE}
out_lmm <- scan1_lmm(pr, iron$pheno, kinship, Xcovar=Xcovar, cores=4)
```

For the LOCO (leave one chromosome out) method, provide the list of
kinship matrices as obtained from `calc_kinship()` with
`method="loco"`.

```{r scan1_lmm_loco}
out_lmm_loco <- scan1_lmm(pr, iron$pheno, kinship_loco, Xcovar=Xcovar)
```

To plot the results, we again use `plotscan1` from the
[qtl2plot](https://github.com/rqtl/qtl2plot) package.


Here is a plot of the LOD scores, by Haley-Knott regression and the linear
mixed model using either the standard kinship matrix or the LOCO
method.

```{r plot_lod_scan1_vs_lmm}
color <- c("slateblue", "violetred", "green3")
par(mar=c(5.1, 4.1, 1.1, 1.1))
ymx <- max(rbind(out, out_lmm, out_lmm_loco))
for(i in 1:2) {
    plotscan1(out, lod=i, col=color[1], main=colnames(out)[i],
              ylim=c(0, ymx*1.02))
    plotscan1(out_lmm, lod=i, col=color[2], add=TRUE)
    plotscan1(out_lmm_loco, lod=i, col=color[3], add=TRUE, lty=2)
}
legend("topleft", lwd=2, col=color, c("H-K", "LMM", "LOCO"), bg="gray92", lty=c(1,1,2))
```

For the liver phenotype (top panel), the three methods give quite
different results. The linear mixed model with an overall kinship
matrix gives much lower LOD scores than the other two methods.  On
chromosomes with some evidence of a QTL, the LOCO method gives higher
LOD scores than Haley-Knott, except on chromosome 16 where it gives
lower LOD scores.

For the spleen phenotype (bottom panel), the linear mixed model with an
overall kinship matrix again gives much lower LOD scores than the
other two methods. However, in this case Haley-Knott regression and
the LOCO method give quite similar results.

## Estimated QTL effects

The `scan1()` and `scan1_lmm()` functions return only LOD scores. To
obtain estimated QTL effects, use the functions `scan1coef()` and
`scan1coef_lmm()`. These functions take a single phenotype and the
genotype probabilities for a single chromosome and return a matrix
with the estimated coefficients at each putative QTL location along
the chromosome.

For example, to get the estimated effects on chromosome 2 for the
liver phenotype, we'd do the following:

```{r est_effects_liver_c2}
c2eff <- scan1coef(pr[,"2"], iron$pheno[,"liver"])
```

The result is a matrix, `r nrow(c2eff)` positions &times; `r ncol(c2eff)`
genotypes. An attribute, `"map"` contains the positions of the
calculations. To plot the effects, use the function `plotcoef()` from
the [qtl2plot](https://github.com/rqtl/qtl2plot).

```{r plot_effects_liver_c2}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
col <- c("slateblue", "violetred", "green3")
plotcoef(c2eff, columns=1:3, col=col)
for(i in 1:ncol(c2eff))
    axis(side=4, at=c2eff[nrow(c2eff),i], colnames(c2eff)[i],
         tick=FALSE, col.axis=col[i])
```

The default is to provide phenotype averages for each genotype
group. If instead you want additive and dominance effects, you can

provide a square matrix of _contrasts_, as follows:

```{r est_effects_liver_c2_contr}
c2effB <- scan1coef(pr[,"2"], iron$pheno[,"liver"],
                    contrasts=cbind(mu=c(1,1,1), a=c(-0.5, 0, 0.5), d=c(-0.5, 1, -0.5)))

```

The result will then contain the estimates of `mu`, `a`, and `d`.
Here's a plot of the additive and dominance effects, which are in the
second and third columns.


```{r plot_effects_liver_c2_contr}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
ymx <- max(abs(c2effB[,2:3]))
plotcoef(c2effB, columns=2:3, col=col[2:3])
for(i in 1:2)
    axis(side=4, at=c2effB[nrow(c2eff),i+1], colnames(c2effB)[i+1],
         tick=FALSE, col.axis=col[i])
```

The `scan1coef_lmm()` function works the same way as `scan1coef()` but
also taking a kinship matrix and fitting a linear mixed model (LMM) to
account for a residual polygenic effect. Here's let's use the kinship
matrix from the LOCO method.

```{r est_effects_lmm_liver_c2}
c2eff_lmm <- scan1coef_lmm(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]])
```

Here's a plot of the estimates.

```{r plot_effects_lmm_liver_c2}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
map <- attr(c2eff_lmm, "map")[[1]]
col <- c("slateblue", "violetred", "green3")
plotcoef(c2eff_lmm, columns=1:3, col=col, ylab="Phenotype average")
for(i in 1:ncol(c2eff))
    axis(side=4, at=c2eff_lmm[nrow(c2eff_lmm),i],
         colnames(c2eff_lmm)[i],
         tick=FALSE, col.axis=col[i])
```

You can also get estimated additive and dominance effects, using a
matrix of contrasts.

```{r est_effects_lmm_liver_c2_contr}
c2effB_lmm <- scan1coef(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]],
                        contrasts=cbind(mu=c(1,1,1), a=c(-0.5, 0, 0.5), d=c(-0.5, 1, -0.5)))
```

Here's a plot of the results.

```{r plot_effects_lmm_liver_c2_contr}
par(mar=c(5.1, 4.1, 1.1, 2.6), las=1)
ymx <- max(abs(c2effB_lmm[,2:3]))
plotcoef(c2effB_lmm, columns=2:3, col=col[2:3])
for(i in 1:2)
    axis(side=4, at=c2effB_lmm[nrow(c2eff),i+1], colnames(c2effB_lmm)[i+1],
         tick=FALSE, col.axis=col[i])
```
